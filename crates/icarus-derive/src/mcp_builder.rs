//! Implementation of the icarus::mcp!() builder pattern macro
//!
//! This macro provides a marketplace-first approach to building MCP canisters.
//! Auth is mandatory (not optional) and init(owner: Principal) is always generated
//! to ensure marketplace compatibility.

use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{parse::Parse, parse::ParseStream, Expr, Ident, Result, Token};

/// Builder state tracking what features are enabled
#[derive(Default)]
struct BuilderState {
    has_wasi: bool,
    resources: Vec<Expr>,
    custom_init: Option<Expr>,
    custom_upgrade: Option<Expr>,
}

/// Parse the builder method chain
struct BuilderChain {
    methods: Vec<BuilderMethod>,
}

/// Individual builder method
enum BuilderMethod {
    WithWasi,
    WithResource(Expr),
    OnInit(Expr),
    OnUpgrade(Expr),
    Build,
}

impl Parse for BuilderChain {
    fn parse(input: ParseStream) -> Result<Self> {
        let mut methods = Vec::new();

        while !input.is_empty() {
            input.parse::<Token![.]>()?;
            let method_name: Ident = input.parse()?;

            match method_name.to_string().as_str() {
                "with_wasi" => {
                    let _content;
                    syn::parenthesized!(_content in input);
                    methods.push(BuilderMethod::WithWasi);
                }
                "with_resource" => {
                    let content;
                    syn::parenthesized!(content in input);
                    let resource: Expr = content.parse()?;
                    methods.push(BuilderMethod::WithResource(resource));
                }
                "on_init" => {
                    let content;
                    syn::parenthesized!(content in input);
                    let init_fn: Expr = content.parse()?;
                    methods.push(BuilderMethod::OnInit(init_fn));
                }
                "on_upgrade" => {
                    let content;
                    syn::parenthesized!(content in input);
                    let upgrade_fn: Expr = content.parse()?;
                    methods.push(BuilderMethod::OnUpgrade(upgrade_fn));
                }
                "build" => {
                    let _content;
                    syn::parenthesized!(_content in input);
                    methods.push(BuilderMethod::Build);
                    break; // build() must be last
                }
                _ => {
                    return Err(syn::Error::new(
                        method_name.span(),
                        format!("Unknown builder method: {}", method_name),
                    ));
                }
            }
        }

        Ok(BuilderChain { methods })
    }
}

/// Expand the icarus::mcp!() builder pattern macro
pub fn expand(input: TokenStream) -> TokenStream {
    match expand_mcp_builder(input) {
        Ok(tokens) => tokens.into(),
        Err(err) => err.to_compile_error().into(),
    }
}

fn expand_mcp_builder(input: TokenStream) -> Result<TokenStream2> {
    // Parse the input as a builder chain
    let chain: BuilderChain = syn::parse(input)?;

    // Build state from the method chain
    let mut state = BuilderState::default();

    for method in &chain.methods {
        match method {
            BuilderMethod::WithWasi => {
                state.has_wasi = true;
            }
            BuilderMethod::WithResource(resource) => {
                state.resources.push(resource.clone());
            }
            BuilderMethod::OnInit(init_fn) => {
                state.custom_init = Some(init_fn.clone());
            }
            BuilderMethod::OnUpgrade(upgrade_fn) => {
                state.custom_upgrade = Some(upgrade_fn.clone());
            }
            BuilderMethod::Build => {
                // Final method - generate the complete canister
                break;
            }
        }
    }

    generate_canister_code(&state)
}

fn generate_canister_code(state: &BuilderState) -> Result<TokenStream2> {
    // Generate auth functions (always included)
    let auth_functions = generate_auth_functions();

    // Generate MCP discovery (always included)
    let mcp_functions = generate_mcp_functions();

    // Generate WASI marker if enabled
    let wasi_marker = if state.has_wasi {
        quote! {
            /// WASI support marker generated by icarus::mcp!().with_wasi()
            const _ICARUS_USES_WASI: bool = true;
        }
    } else {
        quote! {}
    };

    // Generate resource initialization calls
    let resource_init = generate_resource_init(&state.resources);

    // Generate WASI initialization if enabled
    let wasi_init = if state.has_wasi {
        quote! {
            // Initialize WASI runtime if available
            #[cfg(all(target_arch = "wasm32", feature = "wasi"))]
            {
                // WASI initialization would go here
                // For now, just mark that WASI is enabled
            }
        }
    } else {
        quote! {}
    };

    // Generate custom init call if provided
    let custom_init = if let Some(ref init_fn) = state.custom_init {
        quote! {
            // Call custom initialization function
            if let Err(e) = (#init_fn)(owner) {
                ic_cdk::println!("Custom init failed: {:?}", e);
            }
        }
    } else {
        quote! {}
    };

    // Generate custom upgrade call if provided
    let custom_upgrade = if let Some(ref upgrade_fn) = state.custom_upgrade {
        quote! {
            // Call custom upgrade function
            if let Err(e) = (#upgrade_fn)() {
                ic_cdk::println!("Custom upgrade failed: {:?}", e);
            }
        }
    } else {
        quote! {}
    };

    // Generate the complete canister code
    let expanded = quote! {
        #wasi_marker

        #auth_functions

        #mcp_functions

        /// Initialize the canister with owner and all enabled features
        /// This is automatically generated by icarus::mcp!() to ensure marketplace compatibility
        #[ic_cdk::init]
        fn init(owner: candid::Principal) {
            use icarus::prelude::*;

            // Initialize authentication (always required for marketplace)
            init_auth(owner);

            #wasi_init

            #resource_init

            #custom_init
        }

        /// Re-initialize runtime state after canister upgrades
        /// Auth state is preserved in stable storage, this restores runtime state
        #[ic_cdk::post_upgrade]
        fn post_upgrade() {
            #wasi_init

            #resource_init

            #custom_upgrade
        }
    };

    Ok(expanded)
}

fn generate_auth_functions() -> TokenStream2 {
    quote! {
        /// Authentication marker generated by icarus::mcp!()
        /// Auth is always included for marketplace compatibility
        const _ICARUS_AUTH_ENABLED: bool = true;

        /// Add a new user with specified role (owner required)
        ///
        /// Roles:
        /// - "user": Standard user access
        /// - "admin": Can use admin-level tools
        #[ic_cdk::update]
        pub fn add_user(principal: candid::Principal, role: String) -> Result<String, String> {
            use icarus::prelude::*;
            // Validate role parameter
            let auth_role = match role.as_str() {
                "user" => AuthRole::User,
                "admin" => AuthRole::Admin,
                _ => return Err(format!("Invalid role '{}'. Must be 'user' or 'admin'", role)),
            };

            match std::panic::catch_unwind(|| {
                add_user(principal, auth_role)
            }) {
                Ok(result) => Ok(result),
                Err(_) => Err("Failed to add user. Check permissions and principal validity.".to_string()),
            }
        }

        /// Remove a user (owner required)
        ///
        /// Restrictions:
        /// - Cannot remove self
        /// - Must have owner role
        #[ic_cdk::update]
        pub fn remove_user(principal: candid::Principal) -> Result<String, String> {
            use icarus::prelude::*;
            match std::panic::catch_unwind(|| {
                remove_user(principal)
            }) {
                Ok(result) => Ok(result),
                Err(_) => Err("Failed to remove user. Check permissions.".to_string()),
            }
        }

        /// Update user role (owner required)
        ///
        /// Only owners can change user roles. This prevents privilege escalation
        /// and ensures canister owners maintain ultimate control.
        #[ic_cdk::update]
        pub fn update_user_role(principal: candid::Principal, role: String) -> Result<String, String> {
            use icarus::prelude::*;
            // Validate role parameter
            let auth_role = match role.as_str() {
                "user" => AuthRole::User,
                "admin" => AuthRole::Admin,
                "owner" => AuthRole::Owner,
                _ => return Err(format!("Invalid role '{}'. Must be 'user', 'admin', or 'owner'", role)),
            };

            match std::panic::catch_unwind(|| {
                update_user_role(principal, auth_role)
            }) {
                Ok(result) => Ok(result),
                Err(_) => Err("Failed to update user role. Only owners can change roles.".to_string()),
            }
        }

        /// Get a user's role (owner can check anyone, users can check self)
        #[ic_cdk::query]
        pub fn get_user_role(principal: candid::Principal) -> Result<String, String> {
            use icarus::prelude::*;
            let caller = ic_cdk::api::msg_caller();

            // Check if caller is owner or checking their own role
            let can_check = if caller == principal {
                // Anyone can check their own role
                true
            } else {
                // Only owners can check other users' roles
                match std::panic::catch_unwind(|| require_role_or_higher(AuthRole::Owner)) {
                    Ok(_) => true,
                    Err(_) => false,
                }
            };

            if !can_check {
                return Err("Permission denied. Can only check your own role or owner can check anyone.".to_string());
            }

            // Get the target user's info
            match get_user(principal) {
                Some(user) => Ok(format!("{:?}", user.role).to_lowercase()),
                None => Err("User not found".to_string()),
            }
        }

        /// List all authorized users (owner required)
        #[ic_cdk::query]
        pub fn list_users() -> Result<Vec<icarus::prelude::User>, String> {
            use icarus::prelude::*;
            match std::panic::catch_unwind(|| {
                list_users()
            }) {
                Ok(users) => Ok(users),
                Err(_) => Err("Permission denied. Owner role required.".to_string()),
            }
        }

        /// Get current caller's authentication information (public)
        ///
        /// Anyone can check their own authentication status.
        /// Returns user info if authenticated, or error if not.
        #[ic_cdk::query]
        pub fn get_current_user() -> Result<icarus::prelude::AuthInfo, String> {
            use icarus::prelude::*;
            match std::panic::catch_unwind(|| {
                get_current_user()
            }) {
                Ok(auth_info) => Ok(auth_info),
                Err(_) => Err("Not authenticated".to_string()),
            }
        }
    }
}

fn generate_mcp_functions() -> TokenStream2 {
    quote! {
        /// MCP marker generated by icarus::mcp!()
        const _ICARUS_MCP_ENABLED: bool = true;

        /// Get all available tools in MCP format
        /// This is automatically generated for marketplace tool discovery
        #[ic_cdk::query]
        pub fn get_tools() -> String {
            // Tool discovery implementation
            let mut tools = Vec::new();

            // For now, return a basic tool set
            // In the future, this would auto-discover tools marked with #[icarus::tool]
            tools.push(serde_json::json!({
                "name": "hello_world",
                "description": "Return a simple hello world greeting",
                "auth_required": true,
                "auth_level": "user"
            }));

            serde_json::to_string(&tools).unwrap_or_else(|_| "[]".to_string())
        }
    }
}

fn generate_resource_init(resources: &[Expr]) -> TokenStream2 {
    if resources.is_empty() {
        return quote! {};
    }

    let init_calls = resources.iter().map(|resource| {
        quote! {
            // Initialize resource
            if let Err(e) = (#resource)() {
                ic_cdk::println!("Resource initialization failed: {:?}", e);
            }
        }
    });

    quote! {
        #(#init_calls)*
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test the parsing logic
    #[test]
    fn test_builder_chain_parsing() {
        let input = quote! {
            .build()
        };
        let chain: Result<BuilderChain> = syn::parse2(input);
        assert!(chain.is_ok());

        let chain = chain.unwrap();
        assert_eq!(chain.methods.len(), 1);
        assert!(matches!(chain.methods[0], BuilderMethod::Build));
    }

    #[test]
    fn test_wasi_builder_parsing() {
        let input = quote! {
            .with_wasi().build()
        };
        let chain: Result<BuilderChain> = syn::parse2(input);
        assert!(chain.is_ok());

        let chain = chain.unwrap();
        assert_eq!(chain.methods.len(), 2);
        assert!(matches!(chain.methods[0], BuilderMethod::WithWasi));
        assert!(matches!(chain.methods[1], BuilderMethod::Build));
    }

    #[test]
    fn test_resource_builder_parsing() {
        let input = quote! {
            .with_resource(my_setup_function).build()
        };
        let chain: Result<BuilderChain> = syn::parse2(input);
        assert!(chain.is_ok());

        let chain = chain.unwrap();
        assert_eq!(chain.methods.len(), 2);
        assert!(matches!(chain.methods[0], BuilderMethod::WithResource(_)));
        assert!(matches!(chain.methods[1], BuilderMethod::Build));
    }

    #[test]
    fn test_multiple_resources_parsing() {
        let input = quote! {
            .with_resource(resource_one)
            .with_resource(resource_two)
            .build()
        };
        let chain: Result<BuilderChain> = syn::parse2(input);
        assert!(chain.is_ok());

        let chain = chain.unwrap();
        assert_eq!(chain.methods.len(), 3);
        assert!(matches!(chain.methods[0], BuilderMethod::WithResource(_)));
        assert!(matches!(chain.methods[1], BuilderMethod::WithResource(_)));
        assert!(matches!(chain.methods[2], BuilderMethod::Build));
    }

    #[test]
    fn test_full_builder_chain_parsing() {
        let input = quote! {
            .with_wasi()
            .with_resource(my_ml_model)
            .on_init(|owner| Ok(()))
            .build()
        };
        let chain: Result<BuilderChain> = syn::parse2(input);
        assert!(chain.is_ok());

        let chain = chain.unwrap();
        assert_eq!(chain.methods.len(), 4);
        assert!(matches!(chain.methods[0], BuilderMethod::WithWasi));
        assert!(matches!(chain.methods[1], BuilderMethod::WithResource(_)));
        assert!(matches!(chain.methods[2], BuilderMethod::OnInit(_)));
        assert!(matches!(chain.methods[3], BuilderMethod::Build));
    }

    #[test]
    fn test_state_building() {
        let input = quote! {
            .with_wasi()
            .with_resource(my_setup)
            .build()
        };
        let chain: BuilderChain = syn::parse2(input).unwrap();

        // Build state from the method chain
        let mut state = BuilderState::default();

        for method in &chain.methods {
            match method {
                BuilderMethod::WithWasi => {
                    state.has_wasi = true;
                }
                BuilderMethod::WithResource(resource) => {
                    state.resources.push(resource.clone());
                }
                BuilderMethod::Build => {
                    break;
                }
                _ => {}
            }
        }

        assert!(state.has_wasi);
        assert_eq!(state.resources.len(), 1);
    }

    #[test]
    fn test_error_cases() {
        // Test empty input - actually this parses as valid but empty methods
        let input = quote! {};
        let chain: Result<BuilderChain> = syn::parse2(input);
        // Empty input is parsed as empty methods list
        assert!(chain.is_ok());
        assert!(chain.unwrap().methods.is_empty());

        // Test missing build() call - this should parse but not have Build method
        let input = quote! {
            .with_wasi()
        };
        let chain: Result<BuilderChain> = syn::parse2(input);
        // This should parse successfully but won't have Build method
        assert!(chain.is_ok());
        let chain = chain.unwrap();
        // Should not end with Build
        assert!(!matches!(chain.methods.last(), Some(BuilderMethod::Build)));
        // Should have WASI method
        assert!(matches!(chain.methods[0], BuilderMethod::WithWasi));
    }

    #[test]
    fn test_code_generation_components() {
        // Test that individual generation functions work
        let auth_functions = generate_auth_functions();
        let auth_code = auth_functions.to_string();

        // Should contain all required auth functions
        assert!(auth_code.contains("add_user"));
        assert!(auth_code.contains("remove_user"));
        assert!(auth_code.contains("get_current_user"));
        assert!(auth_code.contains("list_users"));
        assert!(auth_code.contains("_ICARUS_AUTH_ENABLED"));

        let mcp_functions = generate_mcp_functions();
        let mcp_code = mcp_functions.to_string();

        // Should contain MCP discovery
        assert!(mcp_code.contains("get_tools"));
        assert!(mcp_code.contains("_ICARUS_MCP_ENABLED"));
    }
}
