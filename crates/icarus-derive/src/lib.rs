//! Derive macros for Icarus CDK
//!
//! This crate provides all the procedural macros for building MCP servers
//! that run as Internet Computer canisters. It includes derive macros,
//! attribute macros, and function-like macros for a unified development experience.
//!
//! # Quick Start - Builder Pattern (Recommended)
//!
//! The **NEW** builder pattern is the recommended approach for marketplace-compatible canisters:
//!
//! ```rust,ignore
//! use icarus::prelude::*;
//! use ic_cdk_macros::export_candid;
//!
//! /// Process data with ML model
//! #[ic_cdk::update]
//! #[icarus::tool("Process data with ML model")]
//! pub async fn process_data(data: Vec<f32>) -> Result<Vec<f32>, String> {
//!     // Business logic here
//!     Ok(data)
//! }
//!
//! /// Public endpoint - no auth required
//! #[ic_cdk::query]
//! #[icarus::tool("Get service information", auth = "public")]
//! pub fn get_info() -> String {
//!     "Service information".to_string()
//! }
//!
//! // NEW: Builder pattern - marketplace-compatible MCP canister
//! icarus::mcp! {
//!     .with_wasi()                    // Optional: WASI support
//!     .with_resource(ml_model::setup) // Optional: ML model initialization
//!     .build()                        // Required: generates everything
//! };
//!
//! export_candid!();
//! ```
//!
//! This **single macro call** provides:
//! - **Automatic auth system**: User management with marketplace-required init(owner: Principal)
//! - **MCP tool discovery**: get_tools() endpoint for MCP clients
//! - **WASI support**: Optional ecosystem library compatibility
//! - **Resource initialization**: ML models, databases, custom setup functions
//! - **Upgrade handling**: Proper post_upgrade() function generation
//!
//! # Core Macros
//!
//! ## Primary Macro (Recommended)
//! - **`icarus::mcp! { .build() }`**: Builder pattern for complete marketplace-compatible canisters
//! - **`#[icarus::tool()]`**: Mark functions as MCP tools with authentication levels
//!
//! ## Legacy Macros (Deprecated)
//! - **`icarus::auth!()`**: ⚠️ Use builder pattern instead
//! - **`icarus::wasi!()`**: ⚠️ Use `.with_wasi()` in builder pattern
//! - **`icarus::init!()`**: ⚠️ Auto-generated by builder pattern
//!
//! ## Derive Macros
//! - **`#[derive(IcarusStorable)]`**: Generate stable storage implementations
//! - **`#[derive(IcarusStorage)]`**: Generate storage management code
//! - **`#[derive(IcarusType)]`**: Convenience macro for common type patterns

#![warn(missing_docs)]

extern crate proc_macro;

use proc_macro::TokenStream;
use syn::{parse_macro_input, DeriveInput};

mod attr_tool;
mod mcp_builder;
mod storage;
mod utils;

/// Attribute macro for marking functions as MCP tools.
///
/// This attribute macro adds authentication checks and registers the function
/// as an MCP tool for automatic discovery.
///
/// # Example
///
/// ```rust,ignore
/// #[ic_cdk::update]
/// #[icarus::tool("Analyze data with ML model")]
/// pub async fn analyze_data(data: Vec<f32>) -> Result<Vec<f32>, String> {
///     // Tool implementation
///     Ok(data)
/// }
/// ```
///
/// # Authentication
///
/// Tools can specify authentication requirements:
/// - `auth = "public"` - No authentication required
/// - `auth = "user"` - Any authenticated user (default)
/// - `auth = "admin"` - Admin role required
/// - `auth = "owner"` - Owner role required
///
/// ```rust,ignore
/// #[ic_cdk::update]
/// #[icarus::tool("Admin-only function", auth = "admin")]
/// pub fn admin_function() -> String {
///     "admin".to_string()
/// }
/// ```
#[proc_macro_attribute]
pub fn tool(attr: TokenStream, item: TokenStream) -> TokenStream {
    attr_tool::expand(attr, item)
}

/// **NEW**: Builder pattern macro for marketplace-compatible MCP canisters.
///
/// This is the NEW preferred way to build MCP canisters. It uses a builder pattern
/// starting with `icarus::mcp!()` that automatically includes all marketplace requirements.
///
/// # Features
///
/// - **Always includes auth**: Authentication is mandatory for marketplace compatibility
/// - **Generates proper init()**: Always creates `init(owner: Principal)` function
/// - **Extensible resources**: Add ML models, databases, and custom initialization
/// - **WASI support**: Optional WASI runtime integration
/// - **Type-safe building**: Compile-time validation of marketplace requirements
///
/// # Example
///
/// ```rust,ignore
/// use icarus::prelude::*;
/// use ic_cdk_macros::export_candid;
///
/// mod inference;
///
/// #[icarus::tool("Classify images")]
/// #[ic_cdk::update]
/// pub async fn classify_image(data: String) -> Result<f32, String> {
///     // Your tool implementation
///     Ok(0.85)
/// }
///
/// // NEW: Builder pattern - replaces auth!(), mcp!(), init!()
/// icarus::mcp! {
///     .with_wasi()                           // Optional: WASI support
///     .with_resource(inference::setup)       // Optional: ML model init
///     .on_init(|owner| {                     // Optional: custom init logic
///         ic_cdk::println!("Custom init for {}", owner);
///         Ok(())
///     })
///     .build()                               // Required: generates everything
/// };
///
/// export_candid!();
/// ```
///
/// # Builder Methods
///
/// - `.with_wasi()` - Enable WASI runtime support
/// - `.with_resource(fn)` - Add resource initialization function
/// - `.on_init(fn)` - Custom initialization logic with owner access
/// - `.on_upgrade(fn)` - Custom upgrade logic
/// - `.build()` - Generate the complete canister (required)
///
/// # What it generates
///
/// - `init(owner: Principal)` - Marketplace-compliant initialization
/// - `post_upgrade()` - Proper upgrade handling
/// - All auth functions (`add_user`, `remove_user`, etc.)
/// - `get_tools()` - MCP tool discovery
/// - WASI initialization (if enabled)
/// - Resource initialization in proper order
#[proc_macro]
pub fn mcp(input: TokenStream) -> TokenStream {
    mcp_builder::expand(input)
}

/// Derive macro for ICP storable types
///
/// # Examples
/// ```rust,ignore
/// use icarus_derive::IcarusStorable;
///
/// #[derive(IcarusStorable)]
/// struct MyData {
///     value: u64,
/// } // Uses default 1MB bound
///
/// #[derive(IcarusStorable)]
/// #[icarus_storable(unbounded)]
/// struct LargeData {
///     data: Vec<u8>,
/// } // Uses unbounded storage
///
/// #[derive(IcarusStorable)]
/// #[icarus_storable(max_size = "2MB")]
/// struct CustomData {
///     content: String,
/// } // Uses custom 2MB bound
/// ```
#[proc_macro_derive(IcarusStorable, attributes(icarus_storable))]
pub fn derive_icarus_storable(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match storage::expand_icarus_storable(&input) {
        Ok(tokens) => tokens.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

/// Derive macro for simplified storage declaration
///
/// Generates stable storage declarations from a simple struct definition.
/// Automatically assigns memory IDs and handles initialization.
///
/// # Examples
/// ```rust,ignore
/// use icarus_derive::IcarusStorage;
/// use ic_stable_structures::StableBTreeMap;
/// use candid::Principal;
///
/// #[derive(Clone)]
/// struct MemoryEntry {
///     value: String,
/// }
///
/// #[derive(Clone)]
/// struct User {
///     name: String,
/// }
///
/// #[derive(IcarusStorage)]
/// struct Storage {
///     memories: StableBTreeMap<String, MemoryEntry>,
///     counter: u64,
///     users: StableBTreeMap<Principal, User>,
/// }
/// ```
///
/// This generates:
/// - Thread-local storage declarations
/// - Memory manager initialization
/// - Accessor methods for each field
#[proc_macro_derive(IcarusStorage)]
pub fn derive_icarus_storage(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match storage::expand_icarus_storage(&input) {
        Ok(tokens) => tokens.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

/// Derive macro for common Icarus type patterns
///
/// This is a convenience macro that combines IcarusStorable with sensible defaults.
/// You still need to derive the standard traits manually.
///
/// # Examples
/// ```rust,ignore
/// use serde::{Serialize, Deserialize};
/// use candid::CandidType;
/// use icarus_derive::IcarusType;
///
/// #[derive(Debug, Clone, Serialize, Deserialize, CandidType, IcarusType)]
/// struct MemoryEntry {
///     id: String,
///     content: String,
///     created_at: u64,
/// }
/// ```
///
/// This is equivalent to:
/// ```rust,ignore
/// use serde::{Serialize, Deserialize};
/// use candid::CandidType;
/// use icarus_derive::IcarusStorable;
///
/// #[derive(Debug, Clone, Serialize, Deserialize, CandidType, IcarusStorable)]
/// #[icarus_storable(unbounded)]
/// struct MemoryEntry {
///     id: String,
///     content: String,
///     created_at: u64,
/// }
/// ```
#[proc_macro_derive(IcarusType, attributes(icarus_storable))]
pub fn derive_icarus_type(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match storage::expand_icarus_type(&input) {
        Ok(tokens) => tokens.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

// Helper function to parse size strings like "1MB", "2KB", etc.
pub(crate) fn parse_size_string(size: &str) -> u32 {
    let size = size.trim();
    if let Some(num_str) = size.strip_suffix("MB") {
        num_str.trim().parse::<u32>().unwrap_or(1) * 1024 * 1024
    } else if let Some(num_str) = size.strip_suffix("KB") {
        num_str.trim().parse::<u32>().unwrap_or(1) * 1024
    } else if let Some(num_str) = size.strip_suffix("B") {
        num_str.trim().parse::<u32>().unwrap_or(1024)
    } else {
        // Try to parse as raw bytes
        size.parse::<u32>().unwrap_or(1024 * 1024)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_size_string() {
        assert_eq!(parse_size_string("1MB"), 1024 * 1024);
        assert_eq!(parse_size_string("2MB"), 2 * 1024 * 1024);
        assert_eq!(parse_size_string("512KB"), 512 * 1024);
        assert_eq!(parse_size_string("1024B"), 1024);
        assert_eq!(parse_size_string("1048576"), 1048576); // Raw bytes

        // Test with whitespace
        assert_eq!(parse_size_string(" 1MB "), 1024 * 1024);
        assert_eq!(parse_size_string(" 512 KB"), 512 * 1024);

        // Test invalid inputs (should use defaults)
        assert_eq!(parse_size_string("invalid"), 1024 * 1024); // Default 1MB
        assert_eq!(parse_size_string(""), 1024 * 1024);
        assert_eq!(parse_size_string("MB"), 1024 * 1024); // Default when parsing fails
    }

    #[test]
    fn test_parse_size_string_edge_cases() {
        // Test case sensitivity (should be case insensitive)
        assert_eq!(parse_size_string("1mb"), 1024 * 1024);
        assert_eq!(parse_size_string("1MB"), 1024 * 1024);

        // Test zero values
        assert_eq!(parse_size_string("0MB"), 0);
        assert_eq!(parse_size_string("0KB"), 0);
        assert_eq!(parse_size_string("0B"), 0);

        // Test large values
        assert_eq!(parse_size_string("1024MB"), 1024 * 1024 * 1024);

        // Test fractional parts (should be ignored)
        assert_eq!(parse_size_string("1.5MB"), 1024 * 1024); // Should parse as 1MB
    }
}
