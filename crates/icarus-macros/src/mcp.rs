//! Implementation of the mcp!{} declarative macro.

use proc_macro2::TokenStream;
use quote::quote;
use syn::{parse::Parser, Expr, ExprAssign, ExprLit, ExprPath, Lit, Token};

use crate::error::{MacroError, MacroResult};

/// Implementation of the mcp!{} macro.
pub(crate) fn mcp_impl(input: TokenStream) -> MacroResult<TokenStream> {
    let config = if input.is_empty() {
        McpConfig::default()
    } else {
        parse_mcp_config(input)?
    };

    Ok(generate_mcp_server_code(&config))
}

/// Configuration for the MCP server.
#[derive(Debug)]
struct McpConfig {
    /// Service name
    name: String,
    /// Service description
    description: String,
    /// Service version
    version: String,
    /// Enable authentication
    auth: bool,
    /// Enable rate limiting
    rate_limit: bool,
}

impl Default for McpConfig {
    fn default() -> Self {
        Self {
            name: "unknown".to_string(),
            description: "MCP Server generated by Icarus CDK".to_string(),
            version: "1.0.0".to_string(),
            auth: false,
            rate_limit: false,
        }
    }
}

/// Parses the mcp!{} configuration.
fn parse_mcp_config(input: TokenStream) -> MacroResult<McpConfig> {
    let mut config = McpConfig::default();

    // Try to parse as key=value assignments first
    let parser = syn::punctuated::Punctuated::<ExprAssign, Token![,]>::parse_terminated;
    if let Ok(assignments) = parser.parse2(input.clone()) {
        if !assignments.is_empty() {
            // Process key=value pairs
            for assignment in assignments {
                let key = extract_assignment_key(&assignment.left)?;
                let value = extract_assignment_value(&assignment.right)?;

                match key.as_str() {
                    "name" => config.name = value,
                    "description" => config.description = value,
                    "version" => config.version = value,
                    "auth" => {
                        config.auth = value.parse::<bool>().map_err(|_| {
                            MacroError::configuration("auth must be a boolean value")
                        })?;
                    }
                    "rate_limit" => {
                        config.rate_limit = value.parse::<bool>().map_err(|_| {
                            MacroError::configuration("rate_limit must be a boolean value")
                        })?;
                    }
                    _ => {
                        return Err(MacroError::configuration(format!(
                            "Unknown configuration key: {key}"
                        )));
                    }
                }
            }
            return Ok(config);
        }
    }

    // Try builder pattern: .with_auth().build()
    if let Ok(expr) = syn::parse2::<Expr>(input) {
        parse_builder_pattern(&expr, &mut config);
        return Ok(config);
    }

    Ok(config)
}

/// Parses builder pattern: `.with_auth().build()`
fn parse_builder_pattern(expr: &Expr, config: &mut McpConfig) {
    if let Expr::MethodCall(method_call) = expr {
        // Recursively process the receiver first
        parse_builder_pattern(&method_call.receiver, config);

        // Process this method call
        let method_name = method_call.method.to_string();
        #[allow(clippy::match_same_arms)]
        match method_name.as_str() {
            "with_auth" => config.auth = true,
            "with_rate_limit" => config.rate_limit = true,
            "build" => {} // Terminal method, no-op
            _ => {}
        }
    }
}

/// Extracts the key from an assignment expression.
fn extract_assignment_key(expr: &Expr) -> MacroResult<String> {
    match expr {
        Expr::Path(ExprPath { path, .. }) => {
            if let Some(ident) = path.get_ident() {
                Ok(ident.to_string())
            } else {
                Err(MacroError::configuration(
                    "Configuration keys must be simple identifiers",
                ))
            }
        }
        _ => Err(MacroError::configuration(
            "Configuration keys must be identifiers",
        )),
    }
}

/// Extracts the value from an assignment expression.
fn extract_assignment_value(expr: &Expr) -> MacroResult<String> {
    match expr {
        Expr::Lit(ExprLit {
            lit: Lit::Str(lit_str),
            ..
        }) => Ok(lit_str.value()),
        Expr::Lit(ExprLit {
            lit: Lit::Bool(lit_bool),
            ..
        }) => Ok(lit_bool.value.to_string()),
        Expr::Path(ExprPath { path, .. }) => {
            if let Some(ident) = path.get_ident() {
                match ident.to_string().as_str() {
                    "true" => Ok("true".to_string()),
                    "false" => Ok("false".to_string()),
                    _ => Err(MacroError::configuration(
                        "Boolean values must be true or false",
                    )),
                }
            } else {
                Err(MacroError::configuration(
                    "Configuration values must be literals or boolean identifiers",
                ))
            }
        }
        _ => Err(MacroError::configuration(
            "Configuration values must be string or boolean literals",
        )),
    }
}

/// Generates the complete MCP server code.
fn generate_mcp_server_code(config: &McpConfig) -> TokenStream {
    let server_info = generate_server_info(config);
    let list_tools_endpoint = generate_list_tools_endpoint();
    let call_tool_endpoint = generate_call_tool_endpoint();
    let candid_export = generate_candid_export();

    // Generate auth management functions if auth is enabled
    let auth_functions = if config.auth {
        generate_auth_management_functions()
    } else {
        quote! {}
    };

    quote! {
        // Server information
        #server_info

        // MCP endpoints
        #list_tools_endpoint
        #call_tool_endpoint

        // Authentication management (if enabled)
        #auth_functions

        // Candid interface export
        #candid_export
    }
}

/// Generates the server info endpoint.
fn generate_server_info(config: &McpConfig) -> TokenStream {
    let name = &config.name;
    let description = &config.description;
    let version = &config.version;

    quote! {
        /// Returns server information
        #[ic_cdk::query]
        pub fn mcp_server_info() -> String {
            let info = serde_json::json!({
                "name": #name,
                "description": #description,
                "version": #version,
                "protocol_version": "2024-11-05",
                "capabilities": {
                    "tools": {}
                }
            });

            serde_json::to_string(&info).unwrap_or_else(|_| "{}".to_string())
        }
    }
}

/// Generates the list tools endpoint.
fn generate_list_tools_endpoint() -> TokenStream {
    quote! {
        /// Lists all available tools (native Vec for bridge)
        #[ic_cdk::query]
        pub fn list_tools() -> Vec<::icarus_core::Tool> {
            ::icarus_runtime::TOOL_REGISTRY
                .iter()
                .map(|tool_fn| tool_fn())
                .collect()
        }

        /// Lists all available tools (JSON string for MCP protocol)
        #[ic_cdk::query]
        pub fn mcp_list_tools() -> String {
            let tools = list_tools();

            let tool_list = serde_json::json!({
                "tools": tools
            });

            serde_json::to_string(&tool_list).unwrap_or_else(|_| r#"{"tools": []}"#.to_string())
        }
    }
}

/// Generates the call tool endpoint with helper functions for cleaner generated code.
fn generate_call_tool_endpoint() -> TokenStream {
    quote! {
        /// Helper function to create JSON-RPC error responses
        fn create_jsonrpc_error(id: String, code: i32, message: String) -> String {
            let error = serde_json::json!({
                "jsonrpc": "2.0",
                "id": id,
                "error": {
                    "code": code,
                    "message": message
                }
            });
            serde_json::to_string(&error).unwrap_or_else(|_| "{}".to_string())
        }

        /// Helper function to create JSON-RPC success responses
        fn create_jsonrpc_success(id: String, result: serde_json::Value) -> String {
            let response = serde_json::json!({
                "jsonrpc": "2.0",
                "id": id,
                "result": result
            });
            serde_json::to_string(&response).unwrap_or_else(|_| "{}".to_string())
        }

        /// Executes a tool with the given parameters (RMCP-compliant)
        #[ic_cdk::update]
        pub async fn mcp_call_tool(request: String) -> String {
            // Initialize executors on first call
            ::icarus_runtime::initialize_executors();

            // Parse the raw JSON to extract tool name and arguments
            let request_json: serde_json::Value = match serde_json::from_str(&request) {
                Ok(json) => json,
                Err(e) => return create_jsonrpc_error("null".to_string(), -32700, format!("Parse error: {}", e)),
            };

            // Extract request ID for response
            let request_id = request_json.get("id")
                .and_then(|id| id.as_str())
                .unwrap_or("null")
                .to_string();

            // Extract tool name and arguments from params
            let params = match request_json.get("params") {
                Some(p) => p,
                None => return create_jsonrpc_error(request_id, -32602, "Missing params field".to_string()),
            };

            let tool_name = match params.get("name").and_then(|n| n.as_str()) {
                Some(name) => name,
                None => return create_jsonrpc_error(request_id, -32602, "Missing tool name in params".to_string()),
            };

            let arguments = params.get("arguments")
                .cloned()
                .unwrap_or(serde_json::json!({}));

            // Find the tool in the registry
            let tool_id = match ::icarus_core::ToolId::new(tool_name) {
                Ok(id) => id,
                Err(e) => return create_jsonrpc_error(request_id, -32602, format!("Invalid tool name: {}", e)),
            };

            // Convert arguments to JSON string
            let arguments_str = match serde_json::to_string(&arguments) {
                Ok(s) => s,
                Err(e) => return create_jsonrpc_error(request_id, -32602, format!("Failed to serialize arguments: {}", e)),
            };

            // Execute the tool using the registry
            let tool_result = match ::icarus_runtime::ToolRegistry::execute_tool_sync(&tool_id, &arguments_str) {
                Some(Ok(result)) => result,
                Some(Err(e)) => return create_jsonrpc_error(request_id, -32603, format!("Tool execution error: {}", e)),
                None => return create_jsonrpc_error(request_id, -32601, format!("Tool not found: {}", tool_name)),
            };

            // Convert LegacyToolResult to RMCP CallToolResult
            let call_tool_result = match tool_result {
                ::icarus_core::LegacyToolResult::Success { result, .. } => {
                    // Create CallToolResult with text content
                    let content = vec![
                        ::icarus_core::Content::text(result.as_ref())
                    ];
                    ::icarus_core::CallToolResult {
                        content,
                        structured_content: None,
                        is_error: Some(false),
                        meta: None,
                    }
                }
                ::icarus_core::LegacyToolResult::Error { message, .. } => {
                    // Create CallToolResult with error content
                    let content = vec![
                        ::icarus_core::Content::text(message.as_ref())
                    ];
                    ::icarus_core::CallToolResult {
                        content,
                        structured_content: None,
                        is_error: Some(true),
                        meta: None,
                    }
                }
                ::icarus_core::LegacyToolResult::Pending { status, .. } => {
                    // Create CallToolResult with pending status
                    let message = status.as_deref().unwrap_or("Tool execution pending");
                    let content = vec![
                        ::icarus_core::Content::text(message)
                    ];
                    ::icarus_core::CallToolResult {
                        content,
                        structured_content: None,
                        is_error: Some(false),
                        meta: None,
                    }
                }
            };

            // Serialize the CallToolResult and return success response
            match serde_json::to_value(&call_tool_result) {
                Ok(result_json) => create_jsonrpc_success(request_id, result_json),
                Err(e) => create_jsonrpc_error(request_id, -32603, format!("Failed to serialize result: {}", e)),
            }
        }
    }
}

/// Generates authentication management functions.
#[allow(clippy::too_many_lines)]
fn generate_auth_management_functions() -> TokenStream {
    quote! {
        /// Initializes the canister with an admin principal
        #[ic_cdk::init]
        pub fn init(admin: candid::Principal) {
            ::icarus_core::auth::add_admin(admin);
        }

        /// Adds a user with the specified role (admin only)
        #[ic_cdk::update]
        pub fn add_user(principal: candid::Principal, role: String) -> Result<String, String> {
            let caller = ::ic_cdk::caller();
            if !::icarus_core::auth::has_admin_access(&caller) {
                return Err("Admin access required".to_string());
            }

            match role.as_str() {
                "admin" => {
                    ::icarus_core::auth::add_admin(principal);
                    Ok(format!("Added {} as admin", principal))
                }
                "user" => {
                    ::icarus_core::auth::add_user(principal);
                    Ok(format!("Added {} as user", principal))
                }
                _ => Err(format!("Invalid role: {}. Must be 'admin' or 'user'", role))
            }
        }

        /// Removes a user from the whitelist (admin only)
        #[ic_cdk::update]
        pub fn remove_user(principal: candid::Principal) -> Result<String, String> {
            let caller = ::ic_cdk::caller();
            if !::icarus_core::auth::has_admin_access(&caller) {
                return Err("Admin access required".to_string());
            }

            // Try removing from both admin and user lists
            ::icarus_core::auth::remove_admin(&principal);
            ::icarus_core::auth::remove_user(&principal);
            Ok(format!("Removed {}", principal))
        }

        /// Changes a user's role (admin only)
        #[ic_cdk::update]
        pub fn change_role(principal: candid::Principal, role: String) -> Result<String, String> {
            let caller = ::ic_cdk::caller();
            if !::icarus_core::auth::has_admin_access(&caller) {
                return Err("Admin access required".to_string());
            }

            // Remove from both lists first
            ::icarus_core::auth::remove_admin(&principal);
            ::icarus_core::auth::remove_user(&principal);

            // Add to appropriate list
            match role.as_str() {
                "admin" => {
                    ::icarus_core::auth::add_admin(principal);
                    Ok(format!("Changed {} to admin", principal))
                }
                "user" => {
                    ::icarus_core::auth::add_user(principal);
                    Ok(format!("Changed {} to user", principal))
                }
                _ => Err(format!("Invalid role: {}. Must be 'admin' or 'user'", role))
            }
        }

        /// Lists all admin principals (admin only)
        #[ic_cdk::query]
        pub fn list_admins() -> Result<Vec<candid::Principal>, String> {
            let caller = ::ic_cdk::caller();
            if !::icarus_core::auth::has_admin_access(&caller) {
                return Err("Admin access required".to_string());
            }

            Ok(::icarus_core::auth::get_all_admins())
        }

        /// Lists all user principals (admin only)
        #[ic_cdk::query]
        pub fn list_users() -> Result<Vec<candid::Principal>, String> {
            let caller = ::ic_cdk::caller();
            if !::icarus_core::auth::has_admin_access(&caller) {
                return Err("Admin access required".to_string());
            }

            Ok(::icarus_core::auth::get_all_users())
        }

        /// Gets the role of a principal (admin only)
        #[ic_cdk::query]
        pub fn get_role(principal: candid::Principal) -> Result<Option<String>, String> {
            let caller = ::ic_cdk::caller();
            if !::icarus_core::auth::has_admin_access(&caller) {
                return Err("Admin access required".to_string());
            }

            if ::icarus_core::auth::is_admin(&principal) {
                Ok(Some("admin".to_string()))
            } else if ::icarus_core::auth::is_user(&principal) {
                Ok(Some("user".to_string()))
            } else {
                Ok(None)
            }
        }
    }
}

/// Generates the Candid interface export.
fn generate_candid_export() -> TokenStream {
    quote! {
        // Export Candid interface for IC integration
        ic_cdk::export_candid!();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use quote::quote;

    #[test]
    fn test_parse_empty_config() {
        let input = quote! {};
        // Test setup: .expect() is acceptable here since test should panic on parse failure
        let config = parse_mcp_config(input).expect("Failed to parse empty config");
        assert_eq!(config.name, "unknown");
        assert_eq!(config.description, "MCP Server generated by Icarus CDK");
        assert!(!config.auth);
        assert!(!config.rate_limit);
    }

    #[test]
    fn test_parse_config_with_name() {
        let input = quote! {
            name = "calculator",
            description = "A simple calculator"
        };
        // Test setup: .expect() is acceptable here since test should panic on parse failure
        let config = parse_mcp_config(input).expect("Failed to parse config with name");
        assert_eq!(config.name, "calculator");
        assert_eq!(config.description, "A simple calculator");
    }

    #[test]
    fn test_parse_config_with_boolean() {
        let input = quote! {
            auth = true,
            rate_limit = false
        };
        // Test setup: .expect() is acceptable here since test should panic on parse failure
        let config = parse_mcp_config(input).expect("Failed to parse config with boolean");
        assert!(config.auth);
        assert!(!config.rate_limit);
    }

    #[test]
    fn test_invalid_config_key() {
        let input = quote! {
            invalid_key = "value"
        };
        assert!(parse_mcp_config(input).is_err());
    }
}
