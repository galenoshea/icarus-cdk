//! Optional MCP tool wrappers for authentication management
//!
//! This module provides MCP-compatible tool wrappers for the core authentication
//! functions. Tools can optionally include these to expose user management
//! capabilities through the MCP protocol.
//!
//! # Usage
//! ```rust
//! // In your tool's lib.rs
//! use icarus_canister::auth_tools;
//! ```

use crate::auth::{add_user, remove_user, update_user_role, get_auth_status, list_users, AuthRole};
use crate::result::{IcarusResult, IcarusError};
use candid::Principal;

/// Add a user to the authorized users list via MCP
// Note: This is now auto-generated by icarus_module macro
// Kept here for reference and manual inclusion if needed
#[allow(dead_code)]
pub fn manual_add_authorized_user(principal_text: String, role: String) -> IcarusResult<String> {
    // Parse principal from string
    let principal = Principal::from_text(principal_text)
        .map_err(|e| IcarusError::validation("principal", e.to_string()))?;
    
    // Parse role from string
    let auth_role = match role.to_lowercase().as_str() {
        "owner" => AuthRole::Owner,
        "admin" => AuthRole::Admin,
        "user" => AuthRole::User,
        "readonly" => AuthRole::ReadOnly,
        _ => {
            return Err(IcarusError::validation(
                "role",
                "Invalid role. Use: owner, admin, user, or readonly",
            ))
        }
    };
        
    // Call core auth function
    Ok(add_user(principal, auth_role))
}

/// Remove a user from authorized users via MCP
#[allow(dead_code)]
pub fn manual_remove_authorized_user(principal_text: String) -> IcarusResult<String> {
    // Parse principal from string
    let principal = Principal::from_text(principal_text)
        .map_err(|e| IcarusError::validation("principal", e.to_string()))?;
        
    // Call core auth function
    Ok(remove_user(principal))
}

/// Update a user's role via MCP
#[allow(dead_code)]
pub fn manual_update_user_role(principal_text: String, new_role: String) -> IcarusResult<String> {
    // Parse principal from string
    let principal = Principal::from_text(principal_text)
        .map_err(|e| IcarusError::validation("principal", e.to_string()))?;
    
    // Parse role from string
    let auth_role = match new_role.to_lowercase().as_str() {
        "owner" => AuthRole::Owner,
        "admin" => AuthRole::Admin,
        "user" => AuthRole::User,
        "readonly" => AuthRole::ReadOnly,
        _ => return Err(IcarusError::validation("role", "Invalid role")),
    };
        
    // Call core auth function
    Ok(update_user_role(principal, auth_role))
}

/// Get current authentication status via MCP
#[allow(dead_code)]
pub fn manual_auth_status() -> String {
    // Get auth status and serialize to JSON
    serde_json::to_string(&get_auth_status()).unwrap_or_else(|e| {
        format!("{{\"error\": \"Failed to serialize auth status: {}\"}}", e)
    })
}

/// List all authorized users via MCP
#[allow(dead_code)]
pub fn manual_list_authorized_users() -> String {
    // Get users and format as JSON
    let users = list_users();
    serde_json::json!({
        "users": users,
        "total": users.len()
    })
    .to_string()
}